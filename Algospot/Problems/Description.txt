6. 완전탐색
PICNIC

BOARDCOVER
- 바로 풀음 
- 왼쪽/위 칸을 채울 수 있는 경우로 DFS돌리면 된다.
- 가지치기하기 때문에 복잡도는 괜찮은 편이지만, 구현상에서 for문으로
변경 가능할 듯하다. 

CLOCKSYNC
- 바로 풀음
- 스위치를 4번 누른것과 0번 누른것이 같다는 것만 이해하고, 복잡도 계산이 가능하면
  완전탐색으로 바로 접근가능함.
- 하지만 수학식 으로 풀이가능함 (문제의도가 완탐이므로..무시)

7. 분할정복

QUADTREE
- 시간이 좀 오래 걸렸다.
- 우선 완전탐색으로 보면 주어진 문자열로 원래의 이미지를 생성후에, 요구하는 방식으로 압축을 다시하면 되는데
  복잡도가 안나온다.
- 현재 압축이라는 것이 트리를 구성하고 있음을 이해하는 것이 중요하다.
- 그러니까 문자열로 트리를 구성하고 다시 순회방식을 바꾸면 되는 것이다.
  이때 문자열을 트리로 바꾸는 단순한 방법을 요즘 안했더니 시간이 좀 오래걸렸다. 데이터도 잘 안나오고...
- 트리를 처음배울때 Order방식을 배우는데 그 방법과 동일하다고 보면 된다.
- 종만북에서는 트리를 구성하고 가는것이 아니라 압축을 보고 바로 다른 압축을 표현하는데 이 아이디어는 
  트리의 순회의 결과가 주어지면 다른 순회의 결과를 얻을 수 있다는 것을 알면 떠올릴 수 있을 것이다.
- 트리를 구성하나 마나 어차피 O(n)이기에.. 마무리

FENCE
- 바로 풀음
- 분할정복으로 풀 수 있다는 것을 깨닫는게 생각보다 어렵다.
- Merge할때 효율적으로 계산이 가능함을 증명해야 되는데, 중간을 통과하는 직사각형을 구할때 가장 넓은 높이를
  무조건 포함하면 정답을 구할 수 있다는 정당성이 확보되어야 풀 수 있는 문제이다.
- 다만 stdio.h로만 푸는 것을 노력하면서 MIN, MAX Define이 생각보다 비효율적임을 알게 됐다. 
  (함수호출을 비교때 값을 넣을때, 여러번호출)

8. 동적계획법
WILDCARD
 - DP구조를 떠올려 바로 풀 수 있었다.
 - 다만 DP구조상에서 *에 대한 for문이 없이 처리할 수 있는 방법이 있었는데 거기까지는 생각하지 못했다.
   생각하지 못한 이유는 이미 시간복잡도가 나왔기 때문이었다.

JLIS
 - 결국 풀지못하고 해답을 보았다.
 - LIS처럼 DP구조는 떠올렸으나. 내가 떠올린 DP점화식을 어렵게 설정했다 (i,j)로부터 (i-1,j) (i, j-1) 점화식을 만들고 반복적DP를 하려다가
   구조가 제대로 안나왔다. 같은수일 경우 카운팅하면 안되는 등의 문제로..
 - 솔루션을 보고 (i,j) i,j에서 시작하여 앞으로의 인덱스 구조를 보고나니 이게더 DP점화식을 짜기가 쉬웠다. 같은수 처리도 쉬웠고..

PI
 - 쉬웠다. DP문제 치고는 조건처리가 까다롭긴했는데.. DP라는 것만 떠올리면 어렵지 않은 문제

QUANTIZATION
 - 바로 풀었다. 정렬->양자화->구간나누기(완탐)->DP 점화식 순으로 단계별로 문제를 해결했다.
 - 오히려 양자화값이 좀 헷갈렸는데, 정수로 양자화해야하므로 평균값으로 하는데 소수점이 0.5이상일 경우 평균값+1을 해주었다.
   양자화값이 맞는지 확신이 좀 어려워서 께림칙했다.

ASYMTILING
 - 바로 풀었다. DP계산은 단순해서 쉬웠고, 문제는 비대칭을 어떻게 구할것이냐였는데, (모든 경우 - 대칭인 경우)가 떠올라서 풀었다.

POLY
 - 바로 풀었다. 문제 자체에서 최적부분구조를 만들어내는 계수를 찾아내는 것이 핵심이었다.
 - 문제에서 변수가 주어지지 않기 때문에 계수를 정해서 점화식을 만들어주기만 하면 쉽게 구할 수 있다.

NUMB3RS
 - 바로 풀었다. 확률 문제여도 똑같이 최적부분구조가 성립함이 보여서 쉽게 풀었다.

9. 동적계획법 테크닉
PACKING
 - 최적값 구하는 것이, for문을 사용하면서 점화식을 잘못 세웠는지 물건 개수를 무한대인 상태를 계속 구해져서 시간이 좀 걸렸다.
 - 또한 최적화 경로를 구하는 와중에 갱신위치로 구하려고 했는데, 그럴 필요없이 최적화값의 비교로 구한다는 발상을 하지 못하고 해답을 보았다.

TICTACTOE
 - 풀이는 보지 않고 풀었지만, 중간에 게임끝나는 것을 처리하지 않아서 오답이 나왔었다.

NUMBERGAME
 - 바로 풀었다. 처음 관계식을 i,j,k에서 k가 얻은 최대값으로 하는 것으로 해서 최적값을 연산해서 구하려고 했는데, 좀 더 생각해보니 한번에 차이의 최대값을 구할 수 있었다.
 - 관계식에 대해 색다른 방법이어서 문제가 참신했다고 느꼈다.
 - k가 필요없다는 것은 좀 더 개선해야될 점이었다.

BLOCKGAME
 - 풀긴 풀었다. 아.. 시간복잡도 생각할 겨를도 없이 총 경우의 수가 얼마 안되니까 DP를 쓰면 되는 문제이다.
 - 처음에 문자열 비교로 구현하고 해쉬연산만 해서 DP로 했는데 너무 느려서 비트연산을 해야되나 싶었는데 알고보니 그냥 & 빼먹어서 메모리에 저장이 안되고 있었다..딥빢
 - 그래서 비트연산자로 구현했다가 &찾아서 풀었는데, 그냥 문자열 비교해도 풀린다..


10.탐욕법
LUNCHBOX
 - 바로 풀었다. 전자레인지를 사용하는 것은 모든 박스를 다 돌리는 것의 합은 언제나 동일하고, 결국에는 가장 늦게 먹는 애를 앞으로 두기만 하면 된다는 아이디어만 떠올리면 된다.

STRJOIN
 - 바로 풀었다. 가장 작은 것을 합치는 것만 이해하면 된다. 힙구조를 사용하면 NlogN이지만 그냥 가장 작은 두개 해도 N^2으로 풀어지긴 한다.