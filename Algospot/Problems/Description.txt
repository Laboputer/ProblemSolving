6. 완전탐색
PICNIC

BOARDCOVER
- 바로 풀음 
- 왼쪽/위 칸을 채울 수 있는 경우로 DFS돌리면 된다.
- 가지치기하기 때문에 복잡도는 괜찮은 편이지만, 구현상에서 for문으로
변경 가능할 듯하다. 

CLOCKSYNC
- 바로 풀음
- 스위치를 4번 누른것과 0번 누른것이 같다는 것만 이해하고, 복잡도 계산이 가능하면
  완전탐색으로 바로 접근가능함.
- 하지만 수학식 으로 풀이가능함 (문제의도가 완탐이므로..무시)

7. 분할정복

QUADTREE
- 시간이 좀 오래 걸렸다.
- 우선 완전탐색으로 보면 주어진 문자열로 원래의 이미지를 생성후에, 요구하는 방식으로 압축을 다시하면 되는데
  복잡도가 안나온다.
- 현재 압축이라는 것이 트리를 구성하고 있음을 이해하는 것이 중요하다.
- 그러니까 문자열로 트리를 구성하고 다시 순회방식을 바꾸면 되는 것이다.
  이때 문자열을 트리로 바꾸는 단순한 방법을 요즘 안했더니 시간이 좀 오래걸렸다. 데이터도 잘 안나오고...
- 트리를 처음배울때 Order방식을 배우는데 그 방법과 동일하다고 보면 된다.
- 종만북에서는 트리를 구성하고 가는것이 아니라 압축을 보고 바로 다른 압축을 표현하는데 이 아이디어는 
  트리의 순회의 결과가 주어지면 다른 순회의 결과를 얻을 수 있다는 것을 알면 떠올릴 수 있을 것이다.
- 트리를 구성하나 마나 어차피 O(n)이기에.. 마무리

FENCE
- 바로 풀음
- 분할정복으로 풀 수 있다는 것을 깨닫는게 생각보다 어렵다.
- Merge할때 효율적으로 계산이 가능함을 증명해야 되는데, 중간을 통과하는 직사각형을 구할때 가장 넓은 높이를
  무조건 포함하면 정답을 구할 수 있다는 정당성이 확보되어야 풀 수 있는 문제이다.
- 다만 stdio.h로만 푸는 것을 노력하면서 MIN, MAX Define이 생각보다 비효율적임을 알게 됐다. 
  (함수호출을 비교때 값을 넣을때, 여러번호출)

8. 동적계획법
WILDCARD
 - DP구조를 떠올려 바로 풀 수 있었다.
 - 다만 DP구조상에서 *에 대한 for문이 없이 처리할 수 있는 방법이 있었는데 거기까지는 생각하지 못했다.
   생각하지 못한 이유는 이미 시간복잡도가 나왔기 때문이었다.

JLIS
 - 결국 풀지못하고 해답을 보았다.
 - LIS처럼 DP구조는 떠올렸으나. 내가 떠올린 DP점화식을 어렵게 설정했다 (i,j)로부터 (i-1,j) (i, j-1) 점화식을 만들고 반복적DP를 하려다가
   구조가 제대로 안나왔다. 같은수일 경우 카운팅하면 안되는 등의 문제로..
 - 솔루션을 보고 (i,j) i,j에서 시작하여 앞으로의 인덱스 구조를 보고나니 이게더 DP점화식을 짜기가 쉬웠다. 같은수 처리도 쉬웠고..

PI
 - 쉬웠다. DP문제 치고는 조건처리가 까다롭긴했는데.. DP라는 것만 떠올리면 어렵지 않은 문제

QUANTIZATION
 - 바로 풀었다. 정렬->양자화->구간나누기(완탐)->DP 점화식 순으로 단계별로 문제를 해결했다.
 - 오히려 양자화값이 좀 헷갈렸는데, 정수로 양자화해야하므로 평균값으로 하는데 소수점이 0.5이상일 경우 평균값+1을 해주었다.
   양자화값이 맞는지 확신이 좀 어려워서 께림칙했다.

ASYMTILING
 - 바로 풀었다. DP계산은 단순해서 쉬웠고, 문제는 비대칭을 어떻게 구할것이냐였는데, (모든 경우 - 대칭인 경우)가 떠올라서 풀었다.

POLY
 - 바로 풀었다. 문제 자체에서 최적부분구조를 만들어내는 계수를 찾아내는 것이 핵심이었다.
 - 문제에서 변수가 주어지지 않기 때문에 계수를 정해서 점화식을 만들어주기만 하면 쉽게 구할 수 있다.

NUMB3RS
 - 바로 풀었다. 확률 문제여도 똑같이 최적부분구조가 성립함이 보여서 쉽게 풀었다.

9. 동적계획법 테크닉
PACKING
 - 최적값 구하는 것이, for문을 사용하면서 점화식을 잘못 세웠는지 물건 개수를 무한대인 상태를 계속 구해져서 시간이 좀 걸렸다.
 - 또한 최적화 경로를 구하는 와중에 갱신위치로 구하려고 했는데, 그럴 필요없이 최적화값의 비교로 구한다는 발상을 하지 못하고 해답을 보았다.

TICTACTOE
 - 풀이는 보지 않고 풀었지만, 중간에 게임끝나는 것을 처리하지 않아서 오답이 나왔었다.

NUMBERGAME
 - 바로 풀었다. 처음 관계식을 i,j,k에서 k가 얻은 최대값으로 하는 것으로 해서 최적값을 연산해서 구하려고 했는데, 좀 더 생각해보니 한번에 차이의 최대값을 구할 수 있었다.
 - 관계식에 대해 색다른 방법이어서 문제가 참신했다고 느꼈다.
 - k가 필요없다는 것은 좀 더 개선해야될 점이었다.

BLOCKGAME
 - 풀긴 풀었다. 아.. 시간복잡도 생각할 겨를도 없이 총 경우의 수가 얼마 안되니까 DP를 쓰면 되는 문제이다.
 - 처음에 문자열 비교로 구현하고 해쉬연산만 해서 DP로 했는데 너무 느려서 비트연산을 해야되나 싶었는데 알고보니 그냥 & 빼먹어서 메모리에 저장이 안되고 있었다..딥빢
 - 그래서 비트연산자로 구현했다가 &찾아서 풀었는데, 그냥 문자열 비교해도 풀린다..

SUSHI
 - 해답을 보고 풀었다. 냅색 문제임도 알고, O(n*m) 푸는 방법도 알고, 슬라이딩 윈도우가 가능함을 알고 있었으나, 구현하지 못했다.
 - 그냥 mod연산으로 이전값에서 바로 진행하는 아이디어를 해답을 보고나서 알게 되었다.

GENIUS
 - 아주 좋은 문제같다.
 - 혼자 생각으로 d[k,n,s] k분에 n번째곡을 s분지점 재생할 확률을 재생할때로 점화식을 구했고, 메모리초과가 나서 슬라이딩 윈도우까지 적용하여 DP는 성공하여 답을 얻었다. 
   그런데 시간복잡도가 안나와서 해답을 봤는데, d[k,n]을 k분에 n번째 곡을 0분지점 재생할 확률로 구할 수 있음을 알았다. 그래도 시간복잡도가 O(K*N^2)으로 시간초과가 난다.
 - 해답에서 선형변환을 통하여 행렬식으로 관계식구하는 테크닉을 쓰는 것을 떠올리는 건 너무 어려운 내용이었다. 


10.탐욕법
LUNCHBOX
 - 바로 풀었다. 전자레인지를 사용하는 것은 모든 박스를 다 돌리는 것의 합은 언제나 동일하고, 결국에는 가장 늦게 먹는 애를 앞으로 두기만 하면 된다는 아이디어만 떠올리면 된다.

STRJOIN
 - 바로 풀었다. 가장 작은 것을 합치는 것만 이해하면 된다. 힙구조를 사용하면 NlogN이지만 그냥 가장 작은 두개 해도 N^2으로 풀어지긴 한다.

11. 조합탐색

ALLERGY
 - 해답을 보고 풀었다. Set Cover라는 NP Problem문제인데, m이 50이다.
 - 완전탐색으로 가지치기를 통해 풀어야 한다. 처음 F(n, state)로 n번째 사람까지 처리했고 state음식을 먹었을때로 구했고, 최소값이기 때문에 탐색중 초과한 답을 가지치기까지 했으나
   시간초과나서 책을 읽어봤다.
 - 책에서는 탐색 방향을 달리하라는 팁을 봤고 F(m,state) m번째 음식까지 처리했을때, state사람이 처리됐을때로 하니 위 경우와 비슷한 것 같았다.
 - 진정한 해답은 F(state) state사람이 처리됐을때 처리되지 않은 사람에 대하여 먹을 수 있는 음식을 모두 한번씩 처리해보는 것 + 가지치기로 정답을 받았다.
 - 위 경우는 복잡도를 파악하기 어려우나, 솔루션은 무조건 재귀의 깊이가 m이 아니라, 최대 m이 된다.
 - 여기서 더 최적화 할 수 있는데 그리디한 방향(음식을 선택할때 가장 많은 사람이 먹을 수 있는 음식부터 + 사람을 선택할때 가장 적은 음식을 먹을 수 있는 사람부터)을 추가해주면 된다
 - 각 경우에 대한 복잡도를 계산하기 어려웠는데, 탐색의 방향에 따라 복잡도가 크게 달라질 수 있는 것을 아직 정확히 모르겠다.

KAKURO1
 - 2풀기전 그냥 구현문제. 

12. 최적화문제 결정문제로 바꿔 풀기

ARCTIC
 - 바로 풀었다. sqrt를 구현했었는데 오차가 안나왔는지 샘플이 안맞긴했는데 sqrt없애고 걍 거리의 제곱으로 풀었다. 

CANADATRIP
 - 바로 풀었다. 결정문제로 변환이 가능하다는 생각이 들어 수식을 만들었다.
 - 이런 문제는 특히 바운더리값이 틀릴 확률이 높기때문에 수식을 완벽하게 정리하고 간단한 테스트케이스도 넣어가면서 제대로 하는 것이 좋겠다.