6. 완전탐색
PICNIC

BOARDCOVER
- 바로 풀음 
- 왼쪽/위 칸을 채울 수 있는 경우로 DFS돌리면 된다.
- 가지치기하기 때문에 복잡도는 괜찮은 편이지만, 구현상에서 for문으로
변경 가능할 듯하다. 

CLOCKSYNC
- 바로 풀음
- 스위치를 4번 누른것과 0번 누른것이 같다는 것만 이해하고, 복잡도 계산이 가능하면
  완전탐색으로 바로 접근가능함.
- 하지만 수학식 으로 풀이가능함 (문제의도가 완탐이므로..무시)

7. 분할정복

QUADTREE
- 시간이 좀 오래 걸렸다.
- 우선 완전탐색으로 보면 주어진 문자열로 원래의 이미지를 생성후에, 요구하는 방식으로 압축을 다시하면 되는데
  복잡도가 안나온다.
- 현재 압축이라는 것이 트리를 구성하고 있음을 이해하는 것이 중요하다.
- 그러니까 문자열로 트리를 구성하고 다시 순회방식을 바꾸면 되는 것이다.
  이때 문자열을 트리로 바꾸는 단순한 방법을 요즘 안했더니 시간이 좀 오래걸렸다. 데이터도 잘 안나오고...
- 트리를 처음배울때 Order방식을 배우는데 그 방법과 동일하다고 보면 된다.
- 종만북에서는 트리를 구성하고 가는것이 아니라 압축을 보고 바로 다른 압축을 표현하는데 이 아이디어는 
  트리의 순회의 결과가 주어지면 다른 순회의 결과를 얻을 수 있다는 것을 알면 떠올릴 수 있을 것이다.
- 트리를 구성하나 마나 어차피 O(n)이기에.. 마무리

FENCE
- 바로 풀음
- 분할정복으로 풀 수 있다는 것을 깨닫는게 생각보다 어렵다.
- Merge할때 효율적으로 계산이 가능함을 증명해야 되는데, 중간을 통과하는 직사각형을 구할때 가장 넓은 높이를
  무조건 포함하면 정답을 구할 수 있다는 정당성이 확보되어야 풀 수 있는 문제이다.
- 다만 stdio.h로만 푸는 것을 노력하면서 MIN, MAX Define이 생각보다 비효율적임을 알게 됐다. 
  (함수호출을 비교때 값을 넣을때, 여러번호출)