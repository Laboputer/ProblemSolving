6. 완전탐색
PICNIC
- 바로 풀었다. 처음에는 안풀려서 책 한바퀴 돌아서 다시 풀었더니 바로 풀었다.
- 문제 조건상 순서를 강제하면 별도로 구할 필요없는 것이 핵심 아이디어였다.

BOARDCOVER
- 바로 풀음 
- 왼쪽/위 칸을 채울 수 있는 경우로 DFS돌리면 된다.
- 가지치기하기 때문에 복잡도는 괜찮은 편이지만, 구현상에서 for문으로
변경 가능할 듯하다. 

CLOCKSYNC
- 바로 풀음
- 스위치를 4번 누른것과 0번 누른것이 같다는 것만 이해하고, 복잡도 계산이 가능하면
  완전탐색으로 바로 접근가능함.
- 하지만 수학식 으로 풀이가능함 (문제의도가 완탐이므로..무시)

7. 분할정복

QUADTREE
- 시간이 좀 오래 걸렸다.
- 우선 완전탐색으로 보면 주어진 문자열로 원래의 이미지를 생성후에, 요구하는 방식으로 압축을 다시하면 되는데
  복잡도가 안나온다.
- 현재 압축이라는 것이 트리를 구성하고 있음을 이해하는 것이 중요하다.
- 그러니까 문자열로 트리를 구성하고 다시 순회방식을 바꾸면 되는 것이다.
  이때 문자열을 트리로 바꾸는 단순한 방법을 요즘 안했더니 시간이 좀 오래걸렸다. 데이터도 잘 안나오고...
- 트리를 처음배울때 Order방식을 배우는데 그 방법과 동일하다고 보면 된다.
- 종만북에서는 트리를 구성하고 가는것이 아니라 압축을 보고 바로 다른 압축을 표현하는데 이 아이디어는 
  트리의 순회의 결과가 주어지면 다른 순회의 결과를 얻을 수 있다는 것을 알면 떠올릴 수 있을 것이다.
- 트리를 구성하나 마나 어차피 O(n)이기에.. 마무리

FENCE
- 바로 풀음
- 분할정복으로 풀 수 있다는 것을 깨닫는게 생각보다 어렵다.
- Merge할때 효율적으로 계산이 가능함을 증명해야 되는데, 중간을 통과하는 직사각형을 구할때 가장 넓은 높이를
  무조건 포함하면 정답을 구할 수 있다는 정당성이 확보되어야 풀 수 있는 문제이다.
- 다만 stdio.h로만 푸는 것을 노력하면서 MIN, MAX Define이 생각보다 비효율적임을 알게 됐다. 
  (함수호출을 비교때 값을 넣을때, 여러번호출)

- 스택을 활용한 O(N) 방법으로도 풀었다.
- 스택을 이용한 솔루션은 어느정도 알고 있었는데, 솔직히 이유는 몰랐다. 근데 지금은 혼자서도 떠올릴 수 있다.
- 아이디어 도출과정은 이렇다.
1. 답은 H[i] 높이 중 하나이다.
2. H[i]의 Left[i], Right[i]를 결정하면 최적해를 구할 수 있다.
3. Stack을 H[i] 오름차순으로 넣게 되면, Right[k] 는 H[k] > H[i] 인 순간 결정난다. 즉 Right[k] = i-1.
   Left[i]는 스택에 넣는 순간 결정난다. Stack에서 H[k] > H[i]인 스택들을 빼면서 가장 작은 인덱스+1이다. 
4. Right를 결정할때 스택에 머문시간임을 알게되면 자연스럽게 스택을 사용할 생각을 할 수 있다.
 

8. 동적계획법
WILDCARD
 - DP구조를 떠올려 바로 풀 수 있었다.
 - 다만 DP구조상에서 *에 대한 for문이 없이 처리할 수 있는 방법이 있었는데 거기까지는 생각하지 못했다.
   생각하지 못한 이유는 이미 시간복잡도가 나왔기 때문이었다.

JLIS
 - 결국 풀지못하고 해답을 보았다.
 - LIS처럼 DP구조는 떠올렸으나. 내가 떠올린 DP점화식을 어렵게 설정했다 (i,j)로부터 (i-1,j) (i, j-1) 점화식을 만들고 반복적DP를 하려다가
   구조가 제대로 안나왔다. 같은수일 경우 카운팅하면 안되는 등의 문제로..
 - 솔루션을 보고 (i,j) i,j에서 시작하여 앞으로의 인덱스 구조를 보고나니 이게더 DP점화식을 짜기가 쉬웠다. 같은수 처리도 쉬웠고..

PI
 - 쉬웠다. DP문제 치고는 조건처리가 까다롭긴했는데.. DP라는 것만 떠올리면 어렵지 않은 문제

QUANTIZATION
 - 바로 풀었다. 정렬->양자화->구간나누기(완탐)->DP 점화식 순으로 단계별로 문제를 해결했다.
 - 오히려 양자화값이 좀 헷갈렸는데, 정수로 양자화해야하므로 평균값으로 하는데 소수점이 0.5이상일 경우 평균값+1을 해주었다.
   양자화값이 맞는지 확신이 좀 어려워서 께림칙했다.

ASYMTILING
 - 바로 풀었다. DP계산은 단순해서 쉬웠고, 문제는 비대칭을 어떻게 구할것이냐였는데, (모든 경우 - 대칭인 경우)가 떠올라서 풀었다.

POLY
 - 바로 풀었다. 문제 자체에서 최적부분구조를 만들어내는 계수를 찾아내는 것이 핵심이었다.
 - 문제에서 변수가 주어지지 않기 때문에 계수를 정해서 점화식을 만들어주기만 하면 쉽게 구할 수 있다.

NUMB3RS
 - 바로 풀었다. 확률 문제여도 똑같이 최적부분구조가 성립함이 보여서 쉽게 풀었다.

9. 동적계획법 테크닉
PACKING
 - 최적값 구하는 것이, for문을 사용하면서 점화식을 잘못 세웠는지 물건 개수를 무한대인 상태를 계속 구해져서 시간이 좀 걸렸다.
 - 또한 최적화 경로를 구하는 와중에 갱신위치로 구하려고 했는데, 그럴 필요없이 최적화값의 비교로 구한다는 발상을 하지 못하고 해답을 보았다.

TICTACTOE
 - 풀이는 보지 않고 풀었지만, 중간에 게임끝나는 것을 처리하지 않아서 오답이 나왔었다.

NUMBERGAME
 - 바로 풀었다. 처음 관계식을 i,j,k에서 k가 얻은 최대값으로 하는 것으로 해서 최적값을 연산해서 구하려고 했는데, 좀 더 생각해보니 한번에 차이의 최대값을 구할 수 있었다.
 - 관계식에 대해 색다른 방법이어서 문제가 참신했다고 느꼈다.
 - k가 필요없다는 것은 좀 더 개선해야될 점이었다.

BLOCKGAME
 - 풀긴 풀었다. 아.. 시간복잡도 생각할 겨를도 없이 총 경우의 수가 얼마 안되니까 DP를 쓰면 되는 문제이다.
 - 처음에 문자열 비교로 구현하고 해쉬연산만 해서 DP로 했는데 너무 느려서 비트연산을 해야되나 싶었는데 알고보니 그냥 & 빼먹어서 메모리에 저장이 안되고 있었다..딥빢
 - 그래서 비트연산자로 구현했다가 &찾아서 풀었는데, 그냥 문자열 비교해도 풀린다..

SUSHI
 - 해답을 보고 풀었다. 냅색 문제임도 알고, O(n*m) 푸는 방법도 알고, 슬라이딩 윈도우가 가능함을 알고 있었으나, 구현하지 못했다.
 - 그냥 mod연산으로 이전값에서 바로 진행하는 아이디어를 해답을 보고나서 알게 되었다.

GENIUS
 - 아주 좋은 문제같다.
 - 혼자 생각으로 d[k,n,s] k분에 n번째곡을 s분지점 재생할 확률을 재생할때로 점화식을 구했고, 메모리초과가 나서 슬라이딩 윈도우까지 적용하여 DP는 성공하여 답을 얻었다. 
   그런데 시간복잡도가 안나와서 해답을 봤는데, d[k,n]을 k분에 n번째 곡을 0분지점 재생할 확률로 구할 수 있음을 알았다. 그래도 시간복잡도가 O(K*N^2)으로 시간초과가 난다.
 - 해답에서 선형변환을 통하여 행렬식으로 관계식구하는 테크닉을 쓰는 것을 떠올리는 건 너무 어려운 내용이었다. 


10.탐욕법
LUNCHBOX
 - 바로 풀었다. 전자레인지를 사용하는 것은 모든 박스를 다 돌리는 것의 합은 언제나 동일하고, 결국에는 가장 늦게 먹는 애를 앞으로 두기만 하면 된다는 아이디어만 떠올리면 된다.

STRJOIN
 - 바로 풀었다. 가장 작은 것을 합치는 것만 이해하면 된다. 힙구조를 사용하면 NlogN이지만 그냥 가장 작은 두개 해도 N^2으로 풀어지긴 한다.

11. 조합탐색

ALLERGY
 - 해답을 보고 풀었다. Set Cover라는 NP Problem문제인데, m이 50이다.
 - 완전탐색으로 가지치기를 통해 풀어야 한다. 처음 F(n, state)로 n번째 사람까지 처리했고 state음식을 먹었을때로 구했고, 최소값이기 때문에 탐색중 초과한 답을 가지치기까지 했으나
   시간초과나서 책을 읽어봤다.
 - 책에서는 탐색 방향을 달리하라는 팁을 봤고 F(m,state) m번째 음식까지 처리했을때, state사람이 처리됐을때로 하니 위 경우와 비슷한 것 같았다.
 - 진정한 해답은 F(state) state사람이 처리됐을때 처리되지 않은 사람에 대하여 먹을 수 있는 음식을 모두 한번씩 처리해보는 것 + 가지치기로 정답을 받았다.
 - 위 경우는 복잡도를 파악하기 어려우나, 솔루션은 무조건 재귀의 깊이가 m이 아니라, 최대 m이 된다.
 - 여기서 더 최적화 할 수 있는데 그리디한 방향(음식을 선택할때 가장 많은 사람이 먹을 수 있는 음식부터 + 사람을 선택할때 가장 적은 음식을 먹을 수 있는 사람부터)을 추가해주면 된다
 - 각 경우에 대한 복잡도를 계산하기 어려웠는데, 탐색의 방향에 따라 복잡도가 크게 달라질 수 있는 것을 아직 정확히 모르겠다.

KAKURO1
 - 2풀기전 그냥 구현문제. 

12. 최적화문제 결정문제로 바꿔 풀기

ARCTIC
 - 바로 풀었다. sqrt를 구현했었는데 오차가 안나왔는지 샘플이 안맞긴했는데 sqrt없애고 걍 거리의 제곱으로 풀었다. 

CANADATRIP
 - 바로 풀었다. 결정문제로 변환이 가능하다는 생각이 들어 수식을 만들었다.
 - 이런 문제는 특히 바운더리값이 틀릴 확률이 높기때문에 수식을 완벽하게 정리하고 간단한 테스트케이스도 넣어가면서 제대로 하는 것이 좋겠다.

WITHDRAWAL
 - 해답을 보고 풀었다. 처음에는 DP로 접근하였다 d[n][k] n개 과목까지 봤을때 k개 선택한 경우 최소값으로 sumr, sumc를 들고다녔다.
   예제에 대한 답이 나와서 맞을 줄 알았으나 아무리 해봐도 오답이 나오길래.. 다시 곰곰히 생각해보았다.
   근데 최적부분구조가 성립하지 않음을 알았다. 즉 부분 문제의 해가 최소값이 더 크더라도 만약 sumc가 훨씬 작은 값이면  다음 해에 더 작아지는 경우가 생김을 알 수 있다. 왜 오답인지 깨달아서 다행이다..
 - 그렇다면 DP로 구하기 위해서는 sumR, sumC에 대한 Table도 필요한데, 그러면 복잡도가 커져 풀 수 없다.
 - sumR / sumC <= x 로 구할 때 k개 이상 선택하는 것이 가능한가로는 쉽게 접근이 안되었다. 결정 문제를 어떻게 바꿀지 모르겠어서, 해답을 봤다.
 - 이 수식을 0 <= Sum(xC-R)로 바꾼 후 이를 내림차순으로 정렬하여 큰 것만 더하면 쉽게 결정문제로 변환할 수 있었다.
 - 결정문제로 쉽게 풀수 있는 방법으로 수식을 변경하는 것이 너무 어려운 접근같다. 이 부분은 많은 연습을 해야될 것 같다. 
 - 근데 해답은 가장 큰 k개만을 더하는데, K개 이상이면 K+1번째 수가 양수면 무조건 더해줘야하는거 아닌가???

13. 수치해석
RATIO
 - 바로 풀었다. 쉬웠는데 아직 긴가민가한게 이분법에서 바운더리값 처리가 확신이 안서는듯 하다.

14. 정수론
PASS486
 - 해답을 보고 풀었다. O(NsqrtN) 방법은 알아서 풀었는데 에라토스테네스의 체를 이용하여 특정 범위 내의 소인수 분해를 빠르게 하는 방법은 알지 못했다.
 - 에라토스테네스의 체를 이용하여 소수 판별을 구하는 것이 아니라 가장 작은 소인수를 저장하는 것을 이용하여 구할 수 있었다.
 - 시간복잡도는 계산하기 어려워서 모르겠지만 아마도 O(N)에 가까울 것 같다.

POTION
 - 예제를 몇번 해보니 감이 잡혀 풀었다. 우선 아이디어를 증명하는 것이 중요했다.
 - 첫번째로 양수로된 최소로 된 비율을 표현해야 한다. (단위가 정수이므로) 이는 모든 수의 최대 공약수를 나눠주면 된다.
 - 두번째로 이미 가지고 있는 수로부터 비율로 표현해야 하는데, 최대배수를 찾아야 하므로 올림수 비율을 가장 큰 것으로 잡고 맞춰주었더니 풀었다. 

16. 비트마스크
GRADUATION
 - 시간이 좀 걸려서 풀었다. 처음에 비트DP로 설계 했다. d[state][m] 현재 이수 상태가 state이고, m번째 학기가 시작될때 필요한 최소학기수로..
 - dp자체도 이수가능 제약과 선수과목 제약때문에 복잡하긴 해도 잘 구했다.
 - 근데 문제는 시간복잡도가 O(2^N*2^M*M) 이었다. 테케까지하면 너무 간당간당해서 일단 해보고 제출했는데 역시나 시간초과가 났다.
 - 중간에 State가 원하는 만큼 이수하면 저장하고 나가면 되는데, 과목끝에서 State를 세다보니 펑션콜이 많아졌나보다..
 - 과목 끝에다다르면 0 또는 불가값을 날려야하는데 이걸 base로 두면서 두 가지를 전부 처리하려니 코드가 좀 까다로웠다. 중간에 나가면 정답이 뜬다. 복잡도는 같은데...? 
 - 지금 문제 해답을 봤는데 내 방식과 완전히 같다... 소오름

17. 부분합
CHRISTMAS
 - 풀었다. 먼저 첫번째 문제는 부분합으로 %K를 한 결과가 같은 쌍을 구하면 되겠다는 아이디어만 있으면 됐다.
 - 두번째 문제는 회의실 배정 그리디 문제처럼 변형가능하여 그리디하게 풀 수 있었다. 이 아이디어를 떠올리는게 은근히 시간이 좀 걸렸다.
   왜냐하면 s, e를 정할때 모두 다 해줄 수 없어서 %K 같은쌍 중에서도 인덱스 차가 가장 적은 쌍만 뽑아내야겠다고 떠올리기가 쉽지 않아서였다.
 - 그리고 데이터가 누적합을 더할떄 long long이 넘어가는 걸 인지 못하다가.. 뒤늦게 겨우 알아차렸다. 만약 내 알고리즘이 증명이 됐다면
   더 쉽게 찾았을텐데 아쉬웠다.
 - 해답을 보니 첫번째는 같은 솔루션이었지만, 두번째 문제를 DP로 풀었더라..

18. 선형 자료구조
JOSEPHUS
 - 바로 풀었다. N이 작아서 큐를 사용하여 O(NK)로 풀었다.
 - N과 K 크기에 따라 O(N^2), O(N), O(KlogN) 등의 방법이 있다고 한다.

19. 큐와 스택, 데크
BRACKETS2
 - 바로 풀었다. 스택을 이용하면 되겠다는 것을 알면 풀림

ITES
 - 바로 풀었다. 투 포인터로 연속된 구간의 합이 X인 개수를 O(N)에 구하는 방법만 떠올리면 어렵지 않다.
 - 처음에 큐를 이용해서 최대 500만 사이즈만 가지면 되겠다 싶어서 구현했는데, 테케에서 TC가 끝나면 메모리가 자동 소멸될줄 알았는데, 안되더라.
   그래서 그냥 전역에 하나두고 하니 정답이 나왔다. 문법적인 문제가 좀 있었다.
 - 근데 보니까 신호생성기에 규칙이 이미 있어서 큐에 현재 SUM을 구성한 수열을 알지 못해도 맨 처음 값을 알면 다음 신호생성기로 알 수 있다. (다른 코드보면서 알게됨)
 - 그래서 메모리없이 그냥 바로 풀수 있는 문제였다.

21. 트리의 구현과 순회
TRAVERSAL
 - 바로 풀었다. 중위 순회에서 전위순회의 첫번째 요소가 둘로 나눈 다는 것을 알게 되면 트리의 구조가 나온다는 것을 떠올리면 풀린다. 

FORTRESS
 - 혼자 풀긴 풀었다. 문제 상황이 트리로 표현될 수 있다는 사실을 알면 풀 수 있는 문제이다.
 - 처음에는 계층 트리를 구성해서 LCA를 비교하려고 했으나 해답은 나올 것 같으나 복잡한 접근이었다.
 - 그냥 각 원에 대해 몇개의 원이 둘러쌓여 있는지 구해놓고, 임의의 두 원이 같은 계층인지, 다른 계층인지 판단하여 거리를 구하면 됐다.
 - 근데 같은 계층, 다른 계층을 처음에 분리할 생각을 못해서 계속 안나와서 고민했었다.
 - 해답은 트리의 가장 먼 거리를 구하는 알고리즘을 이용하던데, 처음에 떠올렸으나 원의 트리를 정확히 표현하는 것에 어려움이 있어서 포기했었다.

23. 우선순위 큐와 힙
RUNNINGMEDIAN
 - 혼자 풀긴 풀었다. 우선순위 큐 2개를 사용하면 구할 수 있다는 것은 이미 알고 있어서 어렵지 않았으나, 힙 구현에 실패가 있었는지 몇번 시도했다.
 - 먼저 이 문제를 보고 우선순위 큐를 떠올리기 위해서는 우선순위 큐가 삽입 삭제가 빈번할때도 O(logN)이 유지되는 자료구조가 필요함을 깨달아야 한다.

28. 그래프의 깊이 우선 탐색
DICTIONARY
 - 쉬웠다. 다만, 26개 노드라서 반복문으로 구현하다가 실수 몇번 했다.
 - 큐를 이용하면 선행조건이 0인 경우를 바로 찾을 수 있기 때문에 효율적으로 구현할 수 있다.